<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SpringCloud基础]]></title>
    <url>%2Fblog%2F2019%2F02%2F05%2FSpringCloud%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[SpringCloud基础问题集 Eureka与Zookeeper比较，链接 Eureka是AP原则，Zookeeper是CP原则]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pringCloud-zuul]]></title>
    <url>%2Fblog%2F2019%2F02%2F05%2FSpringCloud-zuul%2F</url>
    <content type="text"><![CDATA[SpringCloud-zuul相关依赖123implementation 'org.springframework.cloud:spring-cloud-starter-config'implementation 'org.springframework.cloud:spring-cloud-starter-netflix-eureka-client'implementation 'org.springframework.cloud:spring-cloud-starter-netflix-zuul' yml配置1234567eureka: client: service-url: defaultZone: http://cloud1.com:16001/eureka, http://cloud2.com:16002/eureka, http://cloud3.com:16003/eureka, #服务中心注册地址 instance: instance-id: gateway.com #服务别名 prefer-ip-address: true #显示ip 启动类配置@EnableZuulProxy]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pringCloud-Ribbon]]></title>
    <url>%2Fblog%2F2019%2F02%2F05%2FSpringCloud-Ribbon%2F</url>
    <content type="text"><![CDATA[SpringCloud-RibbonSpringCloud Ribbon 是基于Netflix Ribbon实现的一套客户端均衡负载的工具。本次实验基于Ribbon+RestTemplate 报错异常 java.lang.IllegalStateException: Request URI does not contain a valid hostname: http://CLOUD_PROVIDER1:14001/depts（服务名不能有下划线） 客户端依赖123implementation 'org.springframework.cloud:spring-cloud-starter-eureka'implementation 'org.springframework.cloud:spring-cloud-starter-ribbon'implementation 'org.springframework.cloud:spring-cloud-starter-config' yml配置12345eureka: client: register-with-eureka: false #false表示不向注册中心注册自己。 service-url: defaultZone: http://cloud1.com:16001/eureka/,http://cloud2.com:16002/eureka/,http://cloud3.com:16003/eureka/ RestTemplate12345678@Configurationpublic class ConfigBean &#123; @Bean @LoadBalanced public RestTemplate getRestTemplate()&#123; return new RestTemplate(); &#125;&#125; 启动类1234567@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)@EnableEurekaClientpublic class SpringApplication15001 &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringApplication15001.class, args); &#125;&#125; IRule组件七大算法 RoundRobinRule RandomRule AvailabilityFilteringRule WeightedResponseTimeRule RetryRule BestAvailableRule ZoneAvoidanceRule切换默认算法 12345 @Bean public IRule definedRule()&#123;// return new RandomRule(); return new RetryRule(); &#125; 自定义算法参考 https://github.com/Netflix/ribbon/blob/master/ribbon-loadbalancer/src/main/java/com/netflix/loadbalancer/RandomRule.java轮询，要求每个服务调用5次后在轮询 启动类配置自定义规则类不能与主启动类同包1@RibbonClient(name = "CLOUD-PROVIDER1",configuration = Rule.class)//服务名，自定义规则类 自定义规则类——Rule1234567@Configurationpublic class Rule &#123; @Bean public IRule getRule()&#123; return new RoundRobinRule_ZK(); &#125;&#125; 自定义算法类——RoundRobinRule_ZK1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798package com.zhikuan.ribbon;import com.netflix.client.config.IClientConfig;import com.netflix.loadbalancer.AbstractLoadBalancerRule;import com.netflix.loadbalancer.ILoadBalancer;import com.netflix.loadbalancer.Server;import java.util.List;import java.util.concurrent.ThreadLocalRandom;/** * @author Songzk * @date 2019/2/2 */public class RoundRobinRule_ZK extends AbstractLoadBalancerRule &#123; private static final int NUM = 5; private int totals = 0; private int currentIndex = 0; /** * Randomly choose from all living servers */// @edu.umd.cs.findbugs.annotations.SuppressWarnings(value = "RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE") public Server choose(ILoadBalancer lb, Object key) &#123; if (lb == null) &#123; return null; &#125; Server server = null; while (server == null) &#123; if (Thread.interrupted()) &#123; return null; &#125; List&lt;Server&gt; upList = lb.getReachableServers(); List&lt;Server&gt; allList = lb.getAllServers(); int serverCount = allList.size(); if (serverCount == 0) &#123; /* * No servers. End regardless of pass, because subsequent passes * only get more restrictive. */ return null; &#125; int index = chooseRandomInt(serverCount); server = upList.get(index); if (server == null) &#123; /* * The only time this should happen is if the server list were * somehow trimmed. This is a transient condition. Retry after * yielding. */ Thread.yield(); continue; &#125; if (server.isAlive()) &#123; return (server); &#125; // Shouldn't actually happen.. but must be transient or a bug. server = null; Thread.yield(); &#125; return server; &#125; protected int chooseRandomInt(int serverCount) &#123;// return ThreadLocalRandom.current().nextInt(serverCount);//原始 return getCurrentIndex(serverCount);//自定义 &#125; private int getCurrentIndex(int serverCount)&#123; if(totals&lt;RandomRule_ZK.NUM)&#123; totals ++; &#125;else&#123; totals = 0; if(currentIndex&gt;=serverCount-1)&#123; currentIndex = 0; &#125;else &#123; currentIndex ++; &#125; &#125; return currentIndex; &#125; @Override public Server choose(Object key) &#123; return choose(getLoadBalancer(), key); &#125; @Override public void initWithNiwsConfig(IClientConfig clientConfig) &#123; // TODO Auto-generated method stub &#125;&#125;]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pringCloud-Eureka]]></title>
    <url>%2Fblog%2F2019%2F02%2F05%2FSpringCloud-Eureka%2F</url>
    <content type="text"><![CDATA[SpringCloud-Eureka版本信息Boot版本：2.0.7.RELEASE，Cloud版本：Finchley.SR2 报错处理 ClassNotFoundException for ‘com.google.common.collect.Lists’ java.lang.NoClassDefFoundError: com/google/common/base/Function 诸如此类报错的，需要加入一下依赖1implementation group: 'com.google.guava', name: 'guava', version: '27.0-jre' 服务端一、依赖配置1234dependencies &#123; implementation "org.springframework.cloud:spring-cloud-starter-eureka-server"//2.0以下 implementation "org.springframework.cloud:spring-cloud-starter-netflix-eureka-server"//2.0以上&#125; 二、yml配置123456789eureka: instance: hostname: eureka16001.com #eureka服务端的实例名称 client: register-with-eureka: false #false表示不向注册中心注册自己。 fetch-registry: false #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务 service-url: #单机 defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ #设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址（单机）。 defaultZone: http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/ 客服端一、依赖配置123implementation 'org.springframework.cloud:spring-cloud-starter-config'implementation 'org.springframework.cloud:spring-cloud-starter-netflix-eureka-client'implementation 'org.springframework.boot:spring-boot-starter-actuator' //可选，监控中心 二、yml配置123456789101112eureka: client: service-url: defaultZone: http://localhost:16001/eureka //服务中心地址 instance: instance-id: cloud_prover1_14001 #服务别名 prefer-ip-address: true #访问路劲显示ipinfo: #服务info接口信息 以下字段可以任意的定义 app.name: cloud_provider1 company.name: www.songzhikuan.com group: $ group $ version: $version$ 三、服务发现关于@EnableEurekaClient 与 @EnableDiscoveryClien的详细解释 123456789101112131415@Autowiredprivate DiscoveryClient client;@GetMapping(value = "/dept/discovery") public Object discovery() &#123; List&lt;String&gt; list = client.getServices(); System.out.println("**********" + list); List&lt;ServiceInstance&gt; srvList = client.getInstances("cloud_provider1"); for (ServiceInstance element : srvList) &#123; System.out.println(element.getServiceId() + "\t" + element.getHost() + "\t" + element.getPort() + "\t" + element.getUri()); &#125; return this.client; &#125; 自我保护机制某一时刻某个微服务不可用了，Eureka不会立即清理，依旧会对该服务的信息进行保存。默认情况下，如果Eureka在一定的时间内没有接收到某个微服务实例的心跳，EurekaServer会注销该实例（默认为90秒）。但是当网络分区故障发生时，微服务与EurekaServer之间无法正常通信，以上行为可能变得非常危险了——因为微服务本身是健康的，此时不该注销这个微服务。Eureka通过“自我保护模式”来解决这个问题。当EurekaServer节点在短时间内丢失过多的客户端时（可能发生网络分区故障），这个节点就会进入自我保护模式，EurekaServer会保护服务注册表中的信息，不在删除服务注册表中的数据（也就是不会注销任何的微服务），当网络故障恢复后，该EurekaServer节点会自动退出自我保护模式。在自我保护模式中，EurekaServer会保护服务注册表中的信息，不会注销任何的服务实例，当它收到的心跳数重新恢复到阈值以上时，该EurekaServer节点自动退出自我保护模式，他的设计哲学就是宁可保留错误的服务注册信息，也不盲目的注销可能健康的服务实例。 ## Eureka集群 单机集群测试（不想开虚拟机），修改hosts文件，增加域名映射 1234127.0.0.1 localhost127.0.0.1 cloud1.com127.0.0.1 cloud2.com127.0.0.1 cloud3.com 服务端yml 123456789eureka: instance: hostname: cloud3.com client: register-with-eureka: false #false表示不向注册中心注册自己。 fetch-registry: false #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务 service-url:# defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ #设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址（单机）。 defaultZone: http://cloud1.com:16001/eureka/,http://cloud2.com:16002/eureka/ 客服端yml 12345678910111213eureka: client: service-url:# defaultZone: http://localhost:16001/eureka #服务中心注册地址 单机版 defaultZone: http://cloud1:16001/eureka, http://cloud2:16002/eureka, http://cloud3:16003/eureka, #服务中心注册地址 instance: instance-id: $&#123;spring.application.name&#125;_14301 #服务别名 prefer-ip-address: true #显示ipinfo: #服务info接口信息 app.name: $&#123;spring.application.name&#125; company.name: www.songzhikuan.com group: $&#123; group &#125; version: $&#123;version&#125;]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pringCloud-Feign]]></title>
    <url>%2Fblog%2F2019%2F02%2F05%2FSpringCloud-Feign%2F</url>
    <content type="text"><![CDATA[SpringCloud-Feign公共模块依赖1implementation "org.springframework.cloud:spring-cloud-starter-openfeign" 接口——DeptService12345678910111213141516171819202122232425262728293031323334package com.zhikuan.service;import com.zhikuan.entities.Dept;import org.springframework.cloud.openfeign.FeignClient;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestBody;import java.util.List;/** * @author Songzk * @date 2019/2/2 */@FeignClient(value = "CLOUD-PROVIDER1")public interface DeptService &#123; /** * 新增 */ @PostMapping(value = "dept") boolean addDept(@RequestBody Dept dept); /** * 查询一条 */ @GetMapping(value = "dept/&#123;id&#125;") Dept getDept(@PathVariable("id")Long id) ; /** * 查询全部 */ @GetMapping(value = "depts") List&lt;Dept&gt; getDepts();&#125; 客服端依赖123implementation 'org.springframework.cloud:spring-cloud-starter-netflix-eureka-client'implementation 'org.springframework.cloud:spring-cloud-starter-netflix-ribbon'implementation "org.springframework.cloud:spring-cloud-starter-openfeign" controller12345678910111213141516171819202122232425262728293031323334package com.zhikuan.cloud.controller;import com.zhikuan.service.DeptService;import com.zhikuan.entities.Dept;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RestController;import java.util.List;/** * @author Songzk * @date 2019/1/24 */@RestControllerpublic class DeptController &#123; @Autowired private DeptService deptService; @PostMapping("/consumer/dept/add") public boolean add(Dept dept)&#123; return deptService.addDept(dept); &#125; @GetMapping("/consumer/dept/&#123;id&#125;") public Dept getDept(@PathVariable("id")Long id) &#123; return deptService.getDept(id); &#125; @GetMapping("/consumer/depts") public List&lt;Dept&gt; getDepts() &#123; return deptService.getDepts(); &#125;&#125; 启动类123456789@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)@EnableEurekaClient@EnableFeignClients(basePackages= &#123;"com.zhikuan.service"&#125;)//公共服务接口包@ComponentScan("com.zhikuan.cloud")public class SpringApplication15002 &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringApplication15002.class, args); &#125;&#125;]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[除夕过后，2019已迎面而来]]></title>
    <url>%2Fblog%2F2019%2F02%2F05%2F20190205%2F</url>
    <content type="text"><![CDATA[一直没有做总结习惯，一上手就不知道该从哪开始，谈什么。过去一年里，经常私底下思考，2019我该何去何从，心里面也有些想法，基于对未来的憧憬及对过去的怀恋，总感觉还是要留点东西。岁月如梭，人生匆匆，我们一生就好比坐车一样，有起点站，有终点站，往前看是对未来的渴望，向后看是对过去的回忆，然而未来可期，过去总是容易消失在脑海里。。。 2018，我做了什么这一年是我过得最为忙碌的一年。公司注册、公司名字选取、公司办公地点的拟定、个人技术选型、搞业务等公司开展前期的事情准备，大家都在操心，都很忙。这一年，我们接手了几个项目，项目开展后，忙碌的日子随之而来。从需求分析、评估开发周期、系统报价、系统研发、项目演示，到整个项目的结束，都过得不好。公司人员配备为一个前端工程师、一个后端工程师、一个UI设计师、一名市场业务人员。作为前端工程师的我是最为忙碌的，日常开发我指定是最后一个完成的，这是因为项目在前后端分离后，后端工程师就只关心业务代码的编写，而前端工程师不仅要和UI工程师打交道，还要和后端工程师交流，工作量巨大，往往项目一开展，就是15、16个小时的日工作量，没有双休。 这一年也是非常糟糕的一年。我们都很穷，项目总是没有按时交付，钱总是不到位，身心在被折磨着。每个月要付房租、要生活费、还要还贷款，然而发的钱总是不够。现实就是那么的残酷无情，我们苦苦支撑着、煎熬着，直到后面我倒下了，我放弃了。 这一年也是被父母骂的最多的一年。我再过几年也快30岁了，父母非常的捉急我的婚姻，他们害怕我找不到媳妇。然而这一年是我没有也不能够有时间和金钱的一年，都很穷。在我的认知里，没有钱和时间是找不到媳妇的。 这一年同时也是我收获最多的一年。我学会了怎样去和别人喝酒、抽烟；学会了怎样搭建一个web工程；学会了开公司要整理章程、要发工资、要做财务报表、要做流水；学会了怎样去接外包项目、怎样去与别人讨价还价；学会了两门前端框架React，vue；学会了开发混合App。 2019，我该做点什么？参与支护宝集福活动几年了，每年都获得了不错的成绩，都能获得好几块钱。今更是获得了【超级福星】的称号，这很不错，也希望在2019年非常接地气的扮演好【超级福星】的这个角色。基于此，对2019年的自己提出了几个目标： 第一点，狠抓个人经济，争取在2019年国庆期间买一辆自己的代步车； 第二点，注重个人的社交能力。其中包括视野的横向开阔、礼仪培养、异性交往； 第三点，提升个人工作能力。其中包括学习新知识如flutter、掌握spring系列、拓展前端开发视野如Augular，飞冰，微信小程序、公总号、文档编写、开发文档编写、总结报告编写。。。 第四点，健身计划的定制和实施，争取于2019年端午前后有明显的； 第五点，认真思考2020年的自己应该需要达到什么样的境地。]]></content>
      <categories>
        <category>观点和感想</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot基础]]></title>
    <url>%2Fblog%2F2019%2F02%2F05%2FSpringBoot%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[SpringBoot基础SpringBoot简介版本要求本次学习SpringBoot2.0版本，jdk1.8以上 SpringBoot和SpringMVC、SpringCloud区别SpringBoot是一个快速开发的框架,能够快速的整合第三方框架，简化XML配置，全部采用注解形式，内置Tomcat容器,帮助开发者能够实现快速开发，SpringBoot的Web组件 默认集成的是SpringMVC框架。SpringMVC是控制层SpringCloud依赖与SpringBoot组件，使用SpringMVC编写Http协议接口，同时SpringCloud是一套完整的微服务解决框架 注解@SpringBootApplication@SpringBootApplication 被 @Configuration、@EnableAutoConfiguration、@ComponentScan 注解所修饰， @Configuration@Configuration用于定义配置类，可替换xml配置文件，被注解的类内部包含有一个或多个被@Bean注解的方法，这些方法将会被AnnotationConfigApplicationContext或AnnotationConfigWebApplicationContext类进行扫描，并用于构建bean定义，初始化Spring容器。 1234567public class AppConfig &#123; @Bean public MyBean myBean() &#123; // instantiate, configure and return bean ... &#125;&#125; @ComponentScanComponentScan 用于扫包 @EnableAutoConfigurationEnableAutoConfiguration自动装配 @RestController@RestController返回JSON对象 @responseBody@responseBody注解的作用是将controller的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到response对象的body区，通常用来返回JSON数据或者是XML 数据，需要注意的呢，在使用此注解之后不会再走试图处理器，而是直接将数据写入到输入流中，他的效果等同于通过response对象输出指定格式的数据。 静态资源访问Spring Boot默认提供静态资源目录位置需置于classpath下，目录名需符合如下规则：/static/public/resources /META-INF/resources举例：我们可以在src/main/resources/目录下创建static，在该位置放置一个图片文件。启动程序后，尝试访问http://localhost:8080/D.jpg。如能显示图片，配置成功 模板引擎提供了默认配置的模板引擎主要有以下几种·Thymeleaf·FreeMarker·Velocity·Groovy·Mustache它们默认的模板配置路径为：src/main/resources/templatesfreemarker的使用案例： 引入相关包 123456789&lt;!-- 引入freeMarker的依赖包. gradle配置--&gt;implementation 'org.springframework.boot:spring-boot-starter-freemarker'&lt;!-- 引入freeMarker的依赖包. pom配置--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt;&lt;/dependency&gt; 在src/main/resources/创建一个templates文件夹,后缀为*.ftl 后台代码 12345@RequestMapping("/index") public String index(Map&lt;String, Object&gt; map) &#123; map.put("name","美丽的天使..."); return "index"; &#125; applycation配置 12345678910111213spring: freemarker: allow-request-override: false cache: true check: true charset: UTF-8 content-type:text/html expose-request-attributes:false expose-session-attributes:false expose-spring-macro-helpers:false suffix: template-loader-path:.ftl template-loader-path:classpath:/templates/ 全局捕获异常:@ExceptionHandler表示拦截异常@ControllerAdvice 是 controller 的一个辅助类，最常用的就是作为全局异常处理的切面类@ControllerAdvice 可以指定扫描范围@ControllerAdvice 约定了几种可行的返回值，如果是直接返回 model 类的话，需要使用 @ResponseBody 进行 json 转换 返回 String，表示跳到某个 view返回 modelAndView 返回 model +@ResponseBody 1234567891011@ControllerAdvicepublic class GlobalExceptionHandler &#123; @ExceptionHandler(RuntimeException.class) @ResponseBody public Map&lt;String, Object&gt; exceptionHandler() &#123; Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put("errorCode", "101"); map.put("errorMsg", "系統错误!"); return map; &#125;&#125;]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pringCloud-hystrix]]></title>
    <url>%2Fblog%2F2019%2F02%2F05%2FSpringCloud-hystrix%2F</url>
    <content type="text"><![CDATA[SpringCloud-hystrix异常No fallbackFactory instance of type class feign分析：1、实现了接口FallbackFactory的实现类没有加@Component；2、没有扫描到降级类，如：@ComponentScan(basePackages={“main”,””降级类所在的包”}) 服务熔断依赖配置1implementation 'org.springframework.cloud:spring-cloud-starter-netflix-hystrix' Controller123456789101112131415161718/** * 查询一条 */ @GetMapping(value = "dept/&#123;id&#125;") @HystrixCommand(fallbackMethod = "processHystrix_Get") public Dept getDept(@PathVariable("id")Long id) &#123; Dept d = deptService.get(id); if(d==null)&#123; throw new RuntimeException("该ID：" + id + "没有没有对应的信息"); &#125; return d; &#125; /** * 熔断-异常处理 */ public Dept processHystrix_Get(@PathVariable("id")Long id) &#123; return new Dept().setId(id).setDname("该ID：" + id + "没有没有对应的信息,null--@HystrixCommand").setDbSource("no this database in MySQL"); &#125; 启动类12345678@EnableEurekaClient@SpringBootApplication@EnableHystrixpublic class SpringApplication14004 &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringApplication14004.class, args); &#125;&#125; 服务降级（provider已关闭）在controller中指定熔断handler，增加了代码的耦合度，可以在service统一指定实现了FallbackFactory接口的熔断处理类。 service指定1234567891011121314151617181920212223242526272829303132333435package com.zhikuan.service;import com.zhikuan.entities.Dept;import com.zhikuan.service.hystrix.DeptServiceHandler;import org.springframework.cloud.openfeign.FeignClient;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestBody;import java.util.List;/** * @author Songzk * @date 2019/2/2 */@FeignClient(value = "CLOUD-PROVIDER1",fallbackFactory = DeptServiceHandler.class)public interface DeptService &#123; /** * 新增 */ @PostMapping(value = "dept") boolean addDept(@RequestBody Dept dept); /** * 查询一条 */ @GetMapping(value = "dept/&#123;id&#125;") Dept getDept(@PathVariable("id")Long id) ; /** * 查询全部 */ @GetMapping(value = "depts") List&lt;Dept&gt; getDepts();&#125; 实现类DeptServiceHandler1234567891011121314151617181920212223242526272829303132333435package com.zhikuan.service.hystrix;import com.zhikuan.entities.Dept;import com.zhikuan.service.DeptService;import feign.hystrix.FallbackFactory;import org.springframework.stereotype.Component;import java.util.List;/** * @author Songzk * @date 2019/2/3 */@Componentpublic class DeptServiceHandler implements FallbackFactory&lt;DeptService&gt; &#123; @Override public DeptService create(Throwable cause) &#123; return new DeptService() &#123; @Override public boolean addDept(Dept dept) &#123; return false; &#125; @Override public Dept getDept(Long id) &#123; return new Dept().setId(id).setDname("改ID："+id+" 没有对应的记录,hystrix DeptServiceHandler"); &#125; @Override public List&lt;Dept&gt; getDepts() &#123; return null; &#125; &#125;; &#125;&#125; 客户端yml123456789101112131415spring: profiles: active: dev application: name: cloud_consumer_dept_feignfeign: hystrix: enabled: trueeureka: client: register-with-eureka: false #false表示不向注册中心注册自己。 service-url:# defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ #设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址（单机）。 defaultZone: http://cloud1.com:16001/eureka/,http://cloud2.com:16002/eureka/,http://cloud3.com:16003/eureka/ HystrixDashBoardprovider要配置actuator1234567management: endpoints: web: exposure: exclude: "*" server: port: 14104 dashboard依赖123implementation 'org.springframework.boot:spring-boot-starter'implementation 'org.springframework.cloud:spring-cloud-starter-netflix-hystrix'implementation 'org.springframework.cloud:spring-cloud-starter-netflix-hystrix-dashboard' 启动类配置@EnableHystrixDashboard]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20181113]]></title>
    <url>%2Fblog%2F2018%2F11%2F13%2F20181113%2F</url>
    <content type="text"><![CDATA[####主动触发事件1234567891011121314componentDidMount() &#123; let t = setTimeout(() =&gt; &#123; if (document.createEvent) &#123; console.log('dispatch ... '); const event = document.createEvent('HTMLEvents'); event.initEvent('resize', true, true);//触发resize事件 window.dispatchEvent(event); &#125; else if (document.createEventObject) &#123; document.fireEvent('resize'); &#125; clearTimeout(t); &#125;, 0); &#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>浏览器事件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[h5开发问题集]]></title>
    <url>%2Fblog%2F2018%2F10%2F11%2F20181011%2F</url>
    <content type="text"><![CDATA[键盘遮挡input（android浏览器） 1234567891011121314151617181920/** * *@Title: inputMode *@Params: *@Description: android 键盘弹起会遮住input标签 *@return */ function inputMode()&#123; var systemType = api.systemType; if (systemType == "android") &#123; onresize = function() &#123; if(document.activeElement.tagName=="INPUT" ) &#123; window.setTimeout(function() &#123; document.activeElement.scrollIntoViewIfNeeded(); &#125;,0); &#125; &#125; &#125; &#125; 视频播放状态栏隐藏解决思路：播放页进入全屏状态，apicloud案例1234/*全屏隐藏状态栏*/api.setFullScreen(&#123; fullScreen: true&#125;);]]></content>
      <categories>
        <category>h5</category>
      </categories>
      <tags>
        <tag>h5</tag>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2Fblog%2F2018%2F10%2F10%2F20181010%2F</url>
    <content type="text"><![CDATA[新建正则对象 123const regex = /xyz/;// 或者const regex = new RegExp('xyz'); 修饰符 i:ignoreCase,忽略大小写 g:global,全局搜索 m:multiline1const regex = /xyz/gim; 匹配规则]]></content>
      <categories>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[h5基础回顾]]></title>
    <url>%2Fblog%2F2018%2F10%2F09%2F20181009%2F</url>
    <content type="text"><![CDATA[、和标记的用法定义：、和是组合标签，dl是父标签，dt、dd为子标签且dt与dd同级不能相互嵌套用法： 标题+列表 123456789101112131415161718192021&lt;dl&gt; &lt;dt&gt;Firefox&lt;/dt&gt; &lt;dd&gt;A free, open source, cross-platform, graphical web browser developed by the Mozilla Corporation and hundreds of volunteers.&lt;/dd&gt; &lt;style&gt; &#123;` dt&#123; background: #5f9be3; color:#fff; float:left; //脱离文档 font-weight:bold; margin-right:10px; padding:5px; width:100px; &#125; dd&#123; margin-left: 2em; padding: 5px 0; &#125; `&#125; &lt;/style&gt;&lt;/dl&gt;]]></content>
      <categories>
        <category>Css</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读阮老师网站感想]]></title>
    <url>%2Fblog%2F2018%2F10%2F07%2F20181007%2F</url>
    <content type="text"><![CDATA[正文今天打开了阮一峰老师的网站，初略看了一些内容，大受鼓舞，直到现在编写blog的时候内心都未完全平静下来。 一直以来，都想记录一点关于自己在任何时候的想法，但前方路途的迷茫、个人意志的不坚定让这件事搁置到前段时间才开始实施（初步建立个人网站，目前只链接了blog），今天看了阮老师的网站更坚定了要为自己记点东西。]]></content>
      <categories>
        <category>观点和感想</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CSS基础]]></title>
    <url>%2Fblog%2F2018%2F10%2F05%2FCss%2F</url>
    <content type="text"><![CDATA[布局input标签和span标签一行显示盒子宽度已知，要求span标签和input标签加起来的宽度等于盒子的宽度 给span标签和input标签严格定义宽度，如span 30，input 70， 不要span标签，使用伪类：before，使用绝对布局，input设置相应的marginLeft值harmony123456789101112131415161718192021// jsx &lt;div style=&#123;Styles.item&#125; className=" infoItem userName" onClick=&#123;()=&gt;this.onClick(&#123;type:'userName',com:this.userNameInputCom&#125;)&#125;&gt; &lt;input ref=&#123;com=&gt;this.userNameInputCom=com&#125; onChange=&#123;()=&gt;this.userNameChange(&#123;userNameCom:this.userNameInputCom,passwordCom:this.passwordInputCom&#125;)&#125; /&gt; &lt;/div&gt; const Styles = &#123; wrap: &#123; paddingTop: 30, paddingBottom: 30, paddingLeft: 40, paddingRight: 40, display:'inline-block' &#125;, item:&#123; borderBottom:'1px solid lightgray', position:'relative', paddingTop:'1.5rem', paddingLeft:'3.2rem', paddingBottom:'.5rem' &#125; &#125;; 12345678910111213/*css*/.infoItem:before&#123; content:''; position:absolute; left:1rem; top:1.5rem;&#125;.userName:before&#123; content:'账号';&#125; .password:before&#123; content:'密码'; &#125; 盒子高度未知，盒子垂直居中目前没有好的方法，使用chrome开发者工具查看盒子的高度，用js获取屏幕当前的高度减去盒子高度的一半作为盒子的上外边距，或者干脆就是用百分比估计一个一个的试。 2018-10-08 补充 自适应垂直居中,绝对定位+auto，效果图： 123456789101112131415img.portrait&#123; position:absolute; left:0; right:0; top:0; bottom:0; margin:auto;&#125;/*或者*/ img.portrait&#123; position:absolute; left:50%; top:50%; transform:translate(-50%,-50%);//本身的一半 &#125; 蒙层定义一个同级的空盒子，使用绝对布局，上下左右边距为0，设置透明度，调整zIndex值123456789mask: &#123; position: 'absolute', top: '0', left: '0', right: '0', bottom: '0', background: 'rgba(0, 0, 0, 0.6)', zIndex: '2', &#125;,]]></content>
      <categories>
        <category>Css</category>
      </categories>
      <tags>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git相关命令]]></title>
    <url>%2Fblog%2F2018%2F10%2F02%2FGitOrder%2F</url>
    <content type="text"><![CDATA[git config –list 查看配置 git config user.name 修改用户信息 git remote set-url 修改远程仓库地址 git add 向仓库中添加文件 git commit -m 向仓库中提交文件 git status 查看当前仓库状态 git diff 查看文件前后修改内容 git log 从近到远的提交日志 git reflog 查看命令日志 git reset –hard HEAD^ 回退到上一个版本 git reset –hard HEAD~1 回退到上一个版本 git checkout – 撤销修改 git checkout -b dev 创建dev分支并切换到dev分支 git branch dev 创建dev分支 git checkout dev 切换到dev分支 git branch 查看当前分支 git merge dev 合并dev分支的内容到当前分支上 git branch -d dev 删除分支dev git rm 删除版本库中的文件 git remote add origin git@GitHub.com:SongZhikuan/SongZhikuan.GitHub.io.git 远程仓库连接 git push origin master 推送到远程仓库 git clone git@github.com:SongZhikuan/SongZhikuan.github.io.git 克隆远程仓库到本地 git remote -v 查看远程仓库信息 git checkout -b branch-name origin/branch-name 本地创建和远程分支对应的分支 git branch –set-upstream branch-name origin/branch-name 建立本地分支和远程分支的关联 git pull 从远程抓取分支 git push origin dev:dev 推送本地分支到远程 git checkout -b dev dev 拉去远程分支到本地 git config http.postBuffer 524288000 设置buffer大小为50M git config –unset user.name 删除用户信息]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git使用]]></title>
    <url>%2Fblog%2F2018%2F10%2F02%2FGit%2F</url>
    <content type="text"><![CDATA[回顾一直以来都有使用版本控制系统，但对其使用仅仅有限几个命令，常常需要去google、百度，趁国庆黄金周做点git的使用笔记，方法以后来查阅 安装windows安装，安装地址,安装完成后鼠标右键看到有Git Bash说明安装成功。安装成功后配置用户名和邮箱地址12git config --global user.name "your name"git config --global user.email "you email" 注意 –global代表全局，当前设置环境是全局环境 创建版本库创建文件夹，123$ mkdir GitHub$ cd GitHub$ git init 这样文件夹下有.git 文件夹，这是Git用来跟踪管理仓库的，没事不要动这个文件 创建文件Mycom.js，并编写内容1234567891011121314151617export default class MyCom extends React.Component&#123; constructor(props)&#123; super(props); this.state=&#123; count:0, content:'this is a test page!' &#125; &#125; reder()&#123; const &#123;content&#125;=this.state; return ( &lt;div&gt; &#123;content&#125; &lt;/div&gt; ) &#125;&#125; 添加文件到仓库 1$ git add Mycom.js 添加文件到仓库 1$ git commit -m "新增MyCom文件" -m后面跟本次提交说明，易于阅读和版本回退参照 修改文件提交流程也是两步走，add+commit，与新增文件一样 版本回退返回上一个版本1$ git reset --hard HEAD^ 返回指定版本使用git log 或者 git reflog 查看版本号，根据版本号返回到指定版本1$ git reset --hard 1094a Git提交原理直接上图 撤销撤销工作区到最近一次commit或add的状态1$ git checkout --&lt;file&gt; 如果已经add到暂存区，想要撤销暂存区的修改,1$ git reset HEAD &lt;file&gt; 使用场景 工作区修改后没有添加到暂存区，想放弃工作区的修改，使用命令git checkout – 工作区已经修改，并提交到暂存区,想放弃修改，分两步走，首先使用命令git reset HEAD 回到到场景一，之后按照场景一操作 已经提交了不合适的修改到版本库，并没有推送到远程仓库，想要撤销本次修改，使用git reset –hard HEAD^回退到上一个版本 删除删除工作区文件1$rm &lt;file&gt; 删除版本库文件1$git rm &lt;file&gt; 工作区错删文件，从版本库还原1$git checkout --&lt;file&gt; 远程仓库Git是分布式版本控制系统，克隆在多台机器上的仓库没有主次之分。要使用远程仓库，首先，在GitHub上创建账号。其次，创建SSH Key 1$ssh-keygen -t rsa -C "youremail@example.com" 电脑用户目录下会生成.ssh目录，里面有id_rsa和id_rsa.pub两文件,这是SSH Key的密钥对,id_rsa是私钥，id_rsa.pub是公钥可以给别人用。最后登录GitHub账号，打开Account setting，SSH Keys页面，Add SSH Key ，填上任意的title,key文本框中粘上id_rsa.pub中的内容。提供SSH Key可以让GitHub识别你的电脑确认是你自己推送的内容，而不是别人冒充的，SSH Key可以有多个，让你可以在多台电脑上推送代码（公司、自家屋子里），就问贴不贴心😗。 添加远程仓库GitHub上创建一个仓库，本地仓库中使用命令连接远程仓库1$git remote add origin git@GitHub.com:SongZhikuan/SongZhikuan.GitHub.io.git SongZhikuan是我的GitHub账号,远程库的名字就叫origin，这个名字可以改但一般情况下没有改的必要，origin一看就是远程库，简单明了。 推送当前分支master到远程仓库1$git push -u origin master 由于是第一次master分支，加上了-u的参数，Git不但会把本地master分支的内容推送到远程新的master分支上，还会把本地master分支和远程master分支关联起来，在以后的推送和拉取中可以简化命令1$git push origin master 分支管理创建dev分支并切换到dev分支1$git checkout -b dev 创建dev分支1$git git branch dev 切换到dev分支1$git checkout dev 查看当前分支1$git branch 合并dev分支的内容到当前分支上1$git merge dev 删除分支dev1$git branch -d dev 分支冲突master、dev两分支都对README.md文件做了修改并提交到版本库中，分支合并会产生冲突， 手动修改冲突文件README.md,add、commit后合并成功 此过程中使用git log查看详细信息 分支管理master作为发布稳定版本的分支，dev作为开发分支 准备合并dev分支，请注意–no-ff参数，表示禁用Fast forward：1$ git merge --no-ff -m "merge with no-ff" dev 因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js数组]]></title>
    <url>%2Fblog%2F2018%2F10%2F01%2FjsArray%2F</url>
    <content type="text"><![CDATA[数组本身是对象数组是一段线性分配的内存，通过整数去计算偏移量去访问其中元素。数组可以是很快的数据结构，不幸的是javascript并没有这种像数组一样的数据结构，而是提供了一种类数组特性的特殊对象，它把数组下标转成字符串，用作其属性。属性的检索和更新可以像对象一样一样的，除了有一个可以用整数作为属性名的特性外。 数组可以包含任意混合类型的值在大多数语言中，一个数组要求其所有元素都是相同的类型，而javascript则不然，它允许数组包含任意混合类型的值。 1let misc=['s',10,&#123;name:'demo'&#125;,undefined]; 数组长度不是定值每个数组都有一个length属性，和大多数其它语言不同，javaScript数组的length是没有上限的，使用大于和等于当前length的数字来做下标来保存一个元素，那么length将增大来容纳新的元素，不会发生边界错误。length属性的值是这个数组最大整数属性名上加上1，它不一定等于数组的属性的个数。12let arr = [];//arr.length = 0arr[10000]=true;//arr.length = 10001,arr仅包含一个元素 可以设置length的值，设置更大的值无须给数组分配更多的内存，设置小会删除大于等于length的属性。123let arr = ['aaa','sss','ddd','fff','ggg']; //arr = ['aaa','sss','ddd','fff','ggg']arr.length=3; //arr = ['aaa','sss','ddd']arr[3] = 'qqq'; //arr = ['aaa','sss','ddd','qqq'] 温馨提示：arr[arr.length]=’bbb’与arr.push(‘bbb)结果一样 删除元素delete运算符可以删除数组中的元素，由于数组也是对象。删除的结果是数组中遗留一个空洞，这是因为被删除元素之后的的元素保留了他们最初的下标。javaScript提供了splice方法，删除一些元素并将它们替换为其它元素。splice（param1,param2,…）,第一个参数为序号，第二个参数为要删除的个数，其它的参数会在序号那个点被插入到数组。splice的执行过程是：删除指定元素 -&gt; 移除之后的所有元素并以新的键值重新插入，在大型数组操作中属性删除效率不高。 枚举元素可以像对象一样的用for in来遍历数组的所有属性，没法保证属性的顺序以及可能来自原型链上的属性。使用常规for语句可以规避此类问题。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>数组</tag>
      </tags>
  </entry>
</search>
